import {
  require_prop_types
} from "./chunk-FEWAEXOL.js";
import {
  require_with_selector
} from "./chunk-WJPAJTWI.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js
var react_lifecycles_compat_es_exports = {};
__export(react_lifecycles_compat_es_exports, {
  polyfill: () => polyfill
});
function componentWillMount() {
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== void 0) {
    this.setState(state);
  }
}
function componentWillReceiveProps(nextProps) {
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== void 0 ? state : null;
  }
  this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}
function polyfill(Component) {
  var prototype = Component.prototype;
  if (!prototype || !prototype.isReactComponent) {
    throw new Error("Can only polyfill class components");
  }
  if (typeof Component.getDerivedStateFromProps !== "function" && typeof prototype.getSnapshotBeforeUpdate !== "function") {
    return Component;
  }
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === "function") {
    foundWillMountName = "componentWillMount";
  } else if (typeof prototype.UNSAFE_componentWillMount === "function") {
    foundWillMountName = "UNSAFE_componentWillMount";
  }
  if (typeof prototype.componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "componentWillReceiveProps";
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
  }
  if (typeof prototype.componentWillUpdate === "function") {
    foundWillUpdateName = "componentWillUpdate";
  } else if (typeof prototype.UNSAFE_componentWillUpdate === "function") {
    foundWillUpdateName = "UNSAFE_componentWillUpdate";
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks"
    );
  }
  if (typeof Component.getDerivedStateFromProps === "function") {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }
  if (typeof prototype.getSnapshotBeforeUpdate === "function") {
    if (typeof prototype.componentDidUpdate !== "function") {
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    }
    prototype.componentWillUpdate = componentWillUpdate;
    var componentDidUpdate = prototype.componentDidUpdate;
    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }
  return Component;
}
var init_react_lifecycles_compat_es = __esm({
  "node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js"() {
    componentWillMount.__suppressDeprecationWarning = true;
    componentWillReceiveProps.__suppressDeprecationWarning = true;
    componentWillUpdate.__suppressDeprecationWarning = true;
  }
});

// node_modules/react-redux/dist/cjs/react-redux.development.cjs
var require_react_redux_development = __commonJS({
  "node_modules/react-redux/dist/cjs/react-redux.development.cjs"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Provider: () => Provider_default,
      ReactReduxContext: () => ReactReduxContext,
      batch: () => batch,
      connect: () => connect_default,
      createDispatchHook: () => createDispatchHook,
      createSelectorHook: () => createSelectorHook,
      createStoreHook: () => createStoreHook,
      shallowEqual: () => shallowEqual,
      useDispatch: () => useDispatch,
      useSelector: () => useSelector,
      useStore: () => useStore
    });
    module.exports = __toCommonJS2(src_exports);
    var React2 = __toESM(require_react());
    var import_with_selector = require_with_selector();
    var ReactOriginal = __toESM(require_react());
    var React = (
      // prettier-ignore
      // @ts-ignore
      "default" in ReactOriginal ? ReactOriginal["default"] : ReactOriginal
    );
    var ContextKey = Symbol.for(`react-redux-context`);
    var gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      if (!React.createContext)
        return {};
      const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
      let realContext = contextMap.get(React.createContext);
      if (!realContext) {
        realContext = React.createContext(
          null
        );
        if (true) {
          realContext.displayName = "ReactRedux";
        }
        contextMap.set(React.createContext, realContext);
      }
      return realContext;
    }
    var ReactReduxContext = getContext();
    var notInitialized = () => {
      throw new Error("uSES not initialized!");
    };
    function createReduxContextHook(context = ReactReduxContext) {
      return function useReduxContext2() {
        const contextValue = React.useContext(context);
        if (!contextValue) {
          throw new Error(
            "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
          );
        }
        return contextValue;
      };
    }
    var useReduxContext = createReduxContextHook();
    var useSyncExternalStoreWithSelector = notInitialized;
    var initializeUseSelector = (fn) => {
      useSyncExternalStoreWithSelector = fn;
    };
    var refEquality = (a, b) => a === b;
    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
      const useSelector2 = (selector, equalityFnOrOptions = {}) => {
        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
        if (true) {
          if (!selector) {
            throw new Error(`You must pass a selector to useSelector`);
          }
          if (typeof selector !== "function") {
            throw new Error(`You must pass a function as a selector to useSelector`);
          }
          if (typeof equalityFn !== "function") {
            throw new Error(
              `You must pass a function as an equality function to useSelector`
            );
          }
        }
        const {
          store,
          subscription,
          getServerState,
          stabilityCheck,
          identityFunctionCheck
        } = useReduxContext2();
        const firstRun = React.useRef(true);
        const wrappedSelector = React.useCallback(
          {
            [selector.name](state) {
              const selected = selector(state);
              if (true) {
                const {
                  identityFunctionCheck: finalIdentityFunctionCheck,
                  stabilityCheck: finalStabilityCheck
                } = {
                  stabilityCheck,
                  identityFunctionCheck,
                  ...devModeChecks
                };
                if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                  const toCompare = selector(state);
                  if (!equalityFn(selected, toCompare)) {
                    let stack = void 0;
                    try {
                      throw new Error();
                    } catch (e) {
                      ;
                      ({ stack } = e);
                    }
                    console.warn(
                      "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                      {
                        state,
                        selected,
                        selected2: toCompare,
                        stack
                      }
                    );
                  }
                }
                if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                  if (selected === state) {
                    let stack = void 0;
                    try {
                      throw new Error();
                    } catch (e) {
                      ;
                      ({ stack } = e);
                    }
                    console.warn(
                      "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                      { stack }
                    );
                  }
                }
                if (firstRun.current)
                  firstRun.current = false;
              }
              return selected;
            }
          }[selector.name],
          [selector, stabilityCheck, devModeChecks.stabilityCheck]
        );
        const selectedState = useSyncExternalStoreWithSelector(
          subscription.addNestedSub,
          store.getState,
          getServerState || store.getState,
          wrappedSelector,
          equalityFn
        );
        React.useDebugValue(selectedState);
        return selectedState;
      };
      Object.assign(useSelector2, {
        withTypes: () => useSelector2
      });
      return useSelector2;
    }
    var useSelector = createSelectorHook();
    var REACT_ELEMENT_TYPE = Symbol.for("react.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Memo = REACT_MEMO_TYPE;
    function isValidElementType(type) {
      if (typeof type === "string" || typeof type === "function") {
        return true;
      }
      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {
        return true;
      }
      if (typeof type === "object" && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {
          return true;
        }
      }
      return false;
    }
    function typeOf(object) {
      if (typeof object === "object" && object !== null) {
        const $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE: {
            const type = object.type;
            switch (type) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type;
              default: {
                const $$typeofType = type && type.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
              }
            }
          }
          case REACT_PORTAL_TYPE: {
            return $$typeof;
          }
        }
      }
      return void 0;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function warning(message) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
    function verify(selector, methodName) {
      if (!selector) {
        throw new Error(`Unexpected value for ${methodName} in connect.`);
      } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
        if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
          warning(
            `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`
          );
        }
      }
    }
    function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
      verify(mapStateToProps, "mapStateToProps");
      verify(mapDispatchToProps, "mapDispatchToProps");
      verify(mergeProps, "mergeProps");
    }
    function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual
    }) {
      let hasRunAtLeastOnce = false;
      let state;
      let ownProps;
      let stateProps;
      let dispatchProps;
      let mergedProps;
      function handleFirstCall(firstState, firstOwnProps) {
        state = firstState;
        ownProps = firstOwnProps;
        stateProps = mapStateToProps(state, ownProps);
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        hasRunAtLeastOnce = true;
        return mergedProps;
      }
      function handleNewPropsAndNewState() {
        stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps)
          dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
      }
      function handleNewProps() {
        if (mapStateToProps.dependsOnOwnProps)
          stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps)
          dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
      }
      function handleNewState() {
        const nextStateProps = mapStateToProps(state, ownProps);
        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
        stateProps = nextStateProps;
        if (statePropsChanged)
          mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
      }
      function handleSubsequentCalls(nextState, nextOwnProps) {
        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
        const stateChanged = !areStatesEqual(
          nextState,
          state,
          nextOwnProps,
          ownProps
        );
        state = nextState;
        ownProps = nextOwnProps;
        if (propsChanged && stateChanged)
          return handleNewPropsAndNewState();
        if (propsChanged)
          return handleNewProps();
        if (stateChanged)
          return handleNewState();
        return mergedProps;
      }
      return function pureFinalPropsSelector(nextState, nextOwnProps) {
        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
      };
    }
    function finalPropsSelectorFactory(dispatch, {
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      ...options
    }) {
      const mapStateToProps = initMapStateToProps(dispatch, options);
      const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
      const mergeProps = initMergeProps(dispatch, options);
      if (true) {
        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
      }
      return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
    }
    function bindActionCreators(actionCreators, dispatch) {
      const boundActionCreators = {};
      for (const key in actionCreators) {
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
          boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
        }
      }
      return boundActionCreators;
    }
    function isPlainObject(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return true;
      let baseProto = proto;
      while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
      }
      return proto === baseProto;
    }
    function verifyPlainObject(value, displayName, methodName) {
      if (!isPlainObject(value)) {
        warning(
          `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`
        );
      }
    }
    function wrapMapToPropsConstant(getConstant) {
      return function initConstantSelector(dispatch) {
        const constant = getConstant(dispatch);
        function constantSelector() {
          return constant;
        }
        constantSelector.dependsOnOwnProps = false;
        return constantSelector;
      };
    }
    function getDependsOnOwnProps(mapToProps) {
      return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
    }
    function wrapMapToPropsFunc(mapToProps, methodName) {
      return function initProxySelector(dispatch, { displayName }) {
        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
          return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
        };
        proxy.dependsOnOwnProps = true;
        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
          proxy.mapToProps = mapToProps;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
          let props = proxy(stateOrDispatch, ownProps);
          if (typeof props === "function") {
            proxy.mapToProps = props;
            proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
            props = proxy(stateOrDispatch, ownProps);
          }
          if (true)
            verifyPlainObject(props, displayName, methodName);
          return props;
        };
        return proxy;
      };
    }
    function createInvalidArgFactory(arg, name) {
      return (dispatch, options) => {
        throw new Error(
          `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`
        );
      };
    }
    function mapDispatchToPropsFactory(mapDispatchToProps) {
      return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(
        (dispatch) => (
          // @ts-ignore
          bindActionCreators(mapDispatchToProps, dispatch)
        )
      ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({
        dispatch
      })) : typeof mapDispatchToProps === "function" ? (
        // @ts-ignore
        wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps")
      ) : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
    }
    function mapStateToPropsFactory(mapStateToProps) {
      return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
        // @ts-ignore
        wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
      ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
    }
    function defaultMergeProps(stateProps, dispatchProps, ownProps) {
      return { ...ownProps, ...stateProps, ...dispatchProps };
    }
    function wrapMergePropsFunc(mergeProps) {
      return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
        let hasRunOnce = false;
        let mergedProps;
        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
          const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
          if (hasRunOnce) {
            if (!areMergedPropsEqual(nextMergedProps, mergedProps))
              mergedProps = nextMergedProps;
          } else {
            hasRunOnce = true;
            mergedProps = nextMergedProps;
            if (true)
              verifyPlainObject(mergedProps, displayName, "mergeProps");
          }
          return mergedProps;
        };
      };
    }
    function mergePropsFactory(mergeProps) {
      return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
    }
    function defaultNoopBatch(callback) {
      callback();
    }
    function createListenerCollection() {
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },
        notify() {
          defaultNoopBatch(() => {
            let listener = first;
            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },
        get() {
          const listeners = [];
          let listener = first;
          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          const listener = last = {
            callback,
            next: null,
            prev: last
          };
          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first = listener;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null)
              return;
            isSubscribed = false;
            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last = listener.prev;
            }
            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first = listener.next;
            }
          };
        }
      };
    }
    var nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      let subscriptionsAmount = 0;
      let selfSubscribed = false;
      function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return () => {
          if (!removed) {
            removed = true;
            cleanupListener();
            tryUnsubscribe();
          }
        };
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return selfSubscribed;
      }
      function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
          unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      function trySubscribeSelf() {
        if (!selfSubscribed) {
          selfSubscribed = true;
          trySubscribe();
        }
      }
      function tryUnsubscribeSelf() {
        if (selfSubscribed) {
          selfSubscribed = false;
          tryUnsubscribe();
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: () => listeners
      };
      return subscription;
    }
    var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
    function is(x, y) {
      if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB))
        return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      const keysA = Object.keys(objA);
      const keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (let i = 0; i < keysA.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }
      return true;
    }
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      $$typeof: true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      $$typeof: true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {
      [ForwardRef]: FORWARD_REF_STATICS,
      [Memo]: MEMO_STATICS
    };
    function getStatics(component) {
      if (isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          const inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent);
          }
        }
        let keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        const targetStatics = getStatics(targetComponent);
        const sourceStatics = getStatics(sourceComponent);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    var useSyncExternalStore = notInitialized;
    var initializeConnect = (fn) => {
      useSyncExternalStore = fn;
    };
    var NO_SUBSCRIPTION_ARRAY = [null, null];
    var stringifyComponent = (Comp) => {
      try {
        return JSON.stringify(Comp);
      } catch (err) {
        return String(Comp);
      }
    };
    function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
      useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);
    }
    function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
      lastWrapperProps.current = wrapperProps;
      renderIsScheduled.current = false;
      if (childPropsFromStoreUpdate.current) {
        childPropsFromStoreUpdate.current = null;
        notifyNestedSubs();
      }
    }
    function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
      if (!shouldHandleStateChanges)
        return () => {
        };
      let didUnsubscribe = false;
      let lastThrownError = null;
      const checkForUpdates = () => {
        if (didUnsubscribe || !isMounted.current) {
          return;
        }
        const latestStoreState = store.getState();
        let newChildProps, error;
        try {
          newChildProps = childPropsSelector(
            latestStoreState,
            lastWrapperProps.current
          );
        } catch (e) {
          error = e;
          lastThrownError = e;
        }
        if (!error) {
          lastThrownError = null;
        }
        if (newChildProps === lastChildProps.current) {
          if (!renderIsScheduled.current) {
            notifyNestedSubs();
          }
        } else {
          lastChildProps.current = newChildProps;
          childPropsFromStoreUpdate.current = newChildProps;
          renderIsScheduled.current = true;
          additionalSubscribeListener();
        }
      };
      subscription.onStateChange = checkForUpdates;
      subscription.trySubscribe();
      checkForUpdates();
      const unsubscribeWrapper = () => {
        didUnsubscribe = true;
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
        if (lastThrownError) {
          throw lastThrownError;
        }
      };
      return unsubscribeWrapper;
    }
    function strictEqual(a, b) {
      return a === b;
    }
    var hasWarnedAboutDeprecatedPureOption = false;
    function connect(mapStateToProps, mapDispatchToProps, mergeProps, {
      // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
      // @ts-ignore
      pure,
      areStatesEqual = strictEqual,
      areOwnPropsEqual = shallowEqual,
      areStatePropsEqual = shallowEqual,
      areMergedPropsEqual = shallowEqual,
      // use React's forwardRef to expose a ref of the wrapped component
      forwardRef = false,
      // the context consumer to use
      context = ReactReduxContext
    } = {}) {
      if (true) {
        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
          hasWarnedAboutDeprecatedPureOption = true;
          warning(
            'The `pure` option has been removed. `connect` is now always a "pure/memoized" component'
          );
        }
      }
      const Context = context;
      const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
      const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
      const initMergeProps = mergePropsFactory(mergeProps);
      const shouldHandleStateChanges = Boolean(mapStateToProps);
      const wrapWithConnect = (WrappedComponent) => {
        if (true) {
          const isValid = isValidElementType(WrappedComponent);
          if (!isValid)
            throw new Error(
              `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(
                WrappedComponent
              )}`
            );
        }
        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
        const displayName = `Connect(${wrappedComponentName})`;
        const selectorFactoryOptions = {
          shouldHandleStateChanges,
          displayName,
          wrappedComponentName,
          WrappedComponent,
          // @ts-ignore
          initMapStateToProps,
          // @ts-ignore
          initMapDispatchToProps,
          initMergeProps,
          areStatesEqual,
          areStatePropsEqual,
          areOwnPropsEqual,
          areMergedPropsEqual
        };
        function ConnectFunction(props) {
          const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {
            const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
            return [props.context, reactReduxForwardedRef2, wrapperProps2];
          }, [props]);
          const ContextToUse = React.useMemo(() => {
            let ResultContext = Context;
            if (propsContext == null ? void 0 : propsContext.Consumer) {
              if (true) {
                const isValid = isContextConsumer(
                  // @ts-ignore
                  React.createElement(propsContext.Consumer, null)
                );
                if (!isValid) {
                  throw new Error(
                    "You must pass a valid React context consumer as `props.context`"
                  );
                }
                ResultContext = propsContext;
              }
            }
            return ResultContext;
          }, [propsContext, Context]);
          const contextValue = React.useContext(ContextToUse);
          const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
          const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
          if (!didStoreComeFromProps && !didStoreComeFromContext) {
            throw new Error(
              `Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`
            );
          }
          const store = didStoreComeFromProps ? props.store : contextValue.store;
          const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
          const childPropsSelector = React.useMemo(() => {
            return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
          }, [store]);
          const [subscription, notifyNestedSubs] = React.useMemo(() => {
            if (!shouldHandleStateChanges)
              return NO_SUBSCRIPTION_ARRAY;
            const subscription2 = createSubscription(
              store,
              didStoreComeFromProps ? void 0 : contextValue.subscription
            );
            const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
            return [subscription2, notifyNestedSubs2];
          }, [store, didStoreComeFromProps, contextValue]);
          const overriddenContextValue = React.useMemo(() => {
            if (didStoreComeFromProps) {
              return contextValue;
            }
            return {
              ...contextValue,
              subscription
            };
          }, [didStoreComeFromProps, contextValue, subscription]);
          const lastChildProps = React.useRef(void 0);
          const lastWrapperProps = React.useRef(wrapperProps);
          const childPropsFromStoreUpdate = React.useRef(void 0);
          const renderIsScheduled = React.useRef(false);
          const isMounted = React.useRef(false);
          const latestSubscriptionCallbackError = React.useRef(
            void 0
          );
          useIsomorphicLayoutEffect(() => {
            isMounted.current = true;
            return () => {
              isMounted.current = false;
            };
          }, []);
          const actualChildPropsSelector = React.useMemo(() => {
            const selector = () => {
              if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                return childPropsFromStoreUpdate.current;
              }
              return childPropsSelector(store.getState(), wrapperProps);
            };
            return selector;
          }, [store, wrapperProps]);
          const subscribeForReact = React.useMemo(() => {
            const subscribe = (reactListener) => {
              if (!subscription) {
                return () => {
                };
              }
              return subscribeUpdates(
                shouldHandleStateChanges,
                store,
                subscription,
                // @ts-ignore
                childPropsSelector,
                lastWrapperProps,
                lastChildProps,
                renderIsScheduled,
                isMounted,
                childPropsFromStoreUpdate,
                notifyNestedSubs,
                reactListener
              );
            };
            return subscribe;
          }, [subscription]);
          useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            wrapperProps,
            childPropsFromStoreUpdate,
            notifyNestedSubs
          ]);
          let actualChildProps;
          try {
            actualChildProps = useSyncExternalStore(
              // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
              subscribeForReact,
              // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
              // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
              actualChildPropsSelector,
              getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
            );
          } catch (err) {
            if (latestSubscriptionCallbackError.current) {
              ;
              err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
            }
            throw err;
          }
          useIsomorphicLayoutEffect(() => {
            latestSubscriptionCallbackError.current = void 0;
            childPropsFromStoreUpdate.current = void 0;
            lastChildProps.current = actualChildProps;
          });
          const renderedWrappedComponent = React.useMemo(() => {
            return (
              // @ts-ignore
              React.createElement(
                WrappedComponent,
                {
                  ...actualChildProps,
                  ref: reactReduxForwardedRef
                }
              )
            );
          }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
          const renderedChild = React.useMemo(() => {
            if (shouldHandleStateChanges) {
              return React.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
            }
            return renderedWrappedComponent;
          }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
          return renderedChild;
        }
        const _Connect = React.memo(ConnectFunction);
        const Connect = _Connect;
        Connect.WrappedComponent = WrappedComponent;
        Connect.displayName = ConnectFunction.displayName = displayName;
        if (forwardRef) {
          const _forwarded = React.forwardRef(
            function forwardConnectRef(props, ref) {
              return React.createElement(Connect, { ...props, reactReduxForwardedRef: ref });
            }
          );
          const forwarded = _forwarded;
          forwarded.displayName = displayName;
          forwarded.WrappedComponent = WrappedComponent;
          return hoistNonReactStatics(forwarded, WrappedComponent);
        }
        return hoistNonReactStatics(Connect, WrappedComponent);
      };
      return wrapWithConnect;
    }
    var connect_default = connect;
    function Provider({
      store,
      context,
      children,
      serverState,
      stabilityCheck = "once",
      identityFunctionCheck = "once"
    }) {
      const contextValue = React.useMemo(() => {
        const subscription = createSubscription(store);
        return {
          store,
          subscription,
          getServerState: serverState ? () => serverState : void 0,
          stabilityCheck,
          identityFunctionCheck
        };
      }, [store, serverState, stabilityCheck, identityFunctionCheck]);
      const previousState = React.useMemo(() => store.getState(), [store]);
      useIsomorphicLayoutEffect(() => {
        const { subscription } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return React.createElement(Context.Provider, { value: contextValue }, children);
    }
    var Provider_default = Provider;
    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
        // @ts-ignore
        createReduxContextHook(context)
      );
      const useStore2 = () => {
        const { store } = useReduxContext2();
        return store;
      };
      Object.assign(useStore2, {
        withTypes: () => useStore2
      });
      return useStore2;
    }
    var useStore = createStoreHook();
    function createDispatchHook(context = ReactReduxContext) {
      const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
      const useDispatch2 = () => {
        const store = useStore2();
        return store.dispatch;
      };
      Object.assign(useDispatch2, {
        withTypes: () => useDispatch2
      });
      return useDispatch2;
    }
    var useDispatch = createDispatchHook();
    var batch = defaultNoopBatch;
    initializeUseSelector(import_with_selector.useSyncExternalStoreWithSelector);
    initializeConnect(React2.useSyncExternalStore);
  }
});

// node_modules/react-redux/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/react-redux/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_redux_development();
    }
  }
});

// node_modules/react-redux-loading-bar/build/loading_bar_ducks.js
var require_loading_bar_ducks = __commonJS({
  "node_modules/react-redux-loading-bar/build/loading_bar_ducks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.showLoading = showLoading;
    exports.hideLoading = hideLoading;
    exports.resetLoading = resetLoading;
    exports.loadingBarReducer = loadingBarReducer;
    exports.DEFAULT_SCOPE = exports.RESET = exports.HIDE = exports.SHOW = void 0;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SHOW = "loading-bar/SHOW";
    exports.SHOW = SHOW;
    var HIDE = "loading-bar/HIDE";
    exports.HIDE = HIDE;
    var RESET = "loading-bar/RESET";
    exports.RESET = RESET;
    var DEFAULT_SCOPE = "default";
    exports.DEFAULT_SCOPE = DEFAULT_SCOPE;
    function showLoading() {
      var scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_SCOPE;
      return {
        type: SHOW,
        payload: {
          scope
        }
      };
    }
    function hideLoading() {
      var scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_SCOPE;
      return {
        type: HIDE,
        payload: {
          scope
        }
      };
    }
    function resetLoading() {
      var scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_SCOPE;
      return {
        type: RESET,
        payload: {
          scope
        }
      };
    }
    function loadingBarReducer() {
      var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var action = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = action.payload || {}, _ref$scope = _ref.scope, scope = _ref$scope === void 0 ? DEFAULT_SCOPE : _ref$scope;
      switch (action.type) {
        case SHOW:
          return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, scope, (state[scope] || 0) + 1));
        case HIDE:
          return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, scope, Math.max(0, (state[scope] || 1) - 1)));
        case RESET:
          return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, scope, 0));
        default:
          return state;
      }
    }
  }
});

// node_modules/react-redux-loading-bar/build/loading_bar.js
var require_loading_bar = __commonJS({
  "node_modules/react-redux-loading-bar/build/loading_bar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.LoadingBar = exports.TERMINATING_ANIMATION_DURATION = exports.ANIMATION_DURATION = exports.PROGRESS_INCREASE = exports.MAX_PROGRESS = exports.UPDATE_TIME = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _reactLifecyclesCompat = (init_react_lifecycles_compat_es(), __toCommonJS(react_lifecycles_compat_es_exports));
    var _propTypes = require_prop_types();
    var _reactRedux = require_cjs();
    var _loading_bar_ducks = require_loading_bar_ducks();
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var UPDATE_TIME = 400;
    exports.UPDATE_TIME = UPDATE_TIME;
    var MAX_PROGRESS = 99;
    exports.MAX_PROGRESS = MAX_PROGRESS;
    var PROGRESS_INCREASE = 20;
    exports.PROGRESS_INCREASE = PROGRESS_INCREASE;
    var ANIMATION_DURATION = UPDATE_TIME * 2;
    exports.ANIMATION_DURATION = ANIMATION_DURATION;
    var TERMINATING_ANIMATION_DURATION = UPDATE_TIME / 2;
    exports.TERMINATING_ANIMATION_DURATION = TERMINATING_ANIMATION_DURATION;
    var initialState = {
      percent: 0,
      status: "hidden"
    };
    var LoadingBar = function(_Component) {
      _inherits(LoadingBar2, _Component);
      var _super = _createSuper(LoadingBar2);
      _createClass(LoadingBar2, null, [{
        key: "shouldStart",
        value: function shouldStart(props, state) {
          return props.loading > 0 && ["hidden", "stopping"].indexOf(state.status) >= 0;
        }
      }, {
        key: "shouldStop",
        value: function shouldStop(props, state) {
          return props.loading === 0 && ["starting", "running"].indexOf(state.status) >= 0;
        }
      }, {
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, prevState) {
          if (LoadingBar2.shouldStart(nextProps, prevState)) {
            return {
              status: "starting"
            };
          }
          if (LoadingBar2.shouldStop(nextProps, prevState)) {
            return {
              status: "stopping"
            };
          }
          return null;
        }
      }]);
      function LoadingBar2(props) {
        var _this;
        _classCallCheck(this, LoadingBar2);
        _this = _super.call(this, props);
        _this.reset = function() {
          _this.terminatingAnimationTimeoutId = null;
          _this.setState(initialState);
        };
        _this.newPercent = function(percent, progressIncrease) {
          var smoothedProgressIncrease = progressIncrease * Math.cos(percent * (Math.PI / 2 / 100));
          return percent + smoothedProgressIncrease;
        };
        _this.simulateProgress = function() {
          _this.setState(function(prevState, _ref) {
            var maxProgress = _ref.maxProgress, progressIncrease = _ref.progressIncrease;
            var percent = prevState.percent;
            var newPercent = _this.newPercent(percent, progressIncrease);
            if (newPercent <= maxProgress) {
              percent = newPercent;
            }
            return {
              percent
            };
          });
        };
        _this.state = _objectSpread({}, initialState);
        return _this;
      }
      _createClass(LoadingBar2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var status = this.state.status;
          if (status === "starting") {
            this.start();
          }
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          var status = this.state.status;
          if (prevState.status !== status) {
            if (status === "starting") {
              this.start();
            }
            if (status === "stopping") {
              this.stop();
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          clearInterval(this.progressIntervalId);
          clearTimeout(this.terminatingAnimationTimeoutId);
        }
      }, {
        key: "start",
        value: function start() {
          if (this.terminatingAnimationTimeoutId) {
            clearTimeout(this.terminatingAnimationTimeoutId);
            this.reset();
          }
          var updateTime = this.props.updateTime;
          this.progressIntervalId = setInterval(this.simulateProgress, updateTime);
          this.setState({
            status: "running"
          });
        }
      }, {
        key: "stop",
        value: function stop() {
          var showFastActions = this.props.showFastActions;
          clearInterval(this.progressIntervalId);
          this.progressIntervalId = null;
          var terminatingAnimationDuration = this.isShown() || showFastActions ? TERMINATING_ANIMATION_DURATION : 0;
          this.terminatingAnimationTimeoutId = setTimeout(this.reset, terminatingAnimationDuration);
          this.setState({
            percent: 100
          });
        }
      }, {
        key: "isShown",
        value: function isShown() {
          var percent = this.state.percent;
          return percent > 0 && percent <= 100;
        }
      }, {
        key: "buildStyle",
        value: function buildStyle() {
          var _this$state = this.state, status = _this$state.status, percent = _this$state.percent;
          var _this$props = this.props, className = _this$props.className, customStyle = _this$props.style;
          var animationDuration = status === "stopping" ? TERMINATING_ANIMATION_DURATION : ANIMATION_DURATION;
          var style = {
            width: "".concat(percent, "%"),
            transition: "width ".concat(animationDuration, "ms linear 0s"),
            msTransition: "width ".concat(animationDuration, "ms linear 0s"),
            WebkitTransition: "width ".concat(animationDuration, "ms linear 0s"),
            MozTransition: "width ".concat(animationDuration, "ms linear 0s"),
            OTransition: "width ".concat(animationDuration, "ms linear 0s"),
            willChange: "width, opacity"
          };
          if (!className) {
            style.height = "3px";
            style.backgroundColor = "red";
            style.position = "absolute";
          }
          if (this.isShown()) {
            style.opacity = "1";
          } else {
            style.opacity = "0";
          }
          return _objectSpread(_objectSpread({}, style), customStyle);
        }
      }, {
        key: "render",
        value: function render() {
          var status = this.state.status;
          var _this$props2 = this.props, direction = _this$props2.direction, className = _this$props2.className;
          if (status === "hidden") {
            return _react["default"].createElement("div", null);
          }
          return _react["default"].createElement("div", {
            style: {
              direction
            }
          }, _react["default"].createElement("div", {
            style: this.buildStyle(),
            className
          }), _react["default"].createElement("div", {
            style: {
              display: "table",
              clear: "both"
            }
          }));
        }
      }]);
      return LoadingBar2;
    }(_react.Component);
    exports.LoadingBar = LoadingBar;
    LoadingBar.propTypes = {
      className: _propTypes.string,
      direction: _propTypes.string,
      loading: _propTypes.number,
      maxProgress: _propTypes.number,
      progressIncrease: _propTypes.number,
      scope: _propTypes.string,
      showFastActions: _propTypes.bool,
      style: _propTypes.object,
      updateTime: _propTypes.number
    };
    LoadingBar.defaultProps = {
      className: "",
      direction: "ltr",
      loading: 0,
      maxProgress: MAX_PROGRESS,
      progressIncrease: PROGRESS_INCREASE,
      scope: _loading_bar_ducks.DEFAULT_SCOPE,
      showFastActions: false,
      style: {},
      updateTime: UPDATE_TIME
    };
    var mapStateToProps = function mapStateToProps2(state, ownProps) {
      return {
        loading: state.loadingBar[ownProps.scope || _loading_bar_ducks.DEFAULT_SCOPE]
      };
    };
    (0, _reactLifecyclesCompat.polyfill)(LoadingBar);
    var ConnectedLoadingBar = (0, _reactRedux.connect)(mapStateToProps)(LoadingBar);
    exports["default"] = ConnectedLoadingBar;
  }
});

// node_modules/react-redux-loading-bar/build/loading_bar_middleware.js
var require_loading_bar_middleware = __commonJS({
  "node_modules/react-redux-loading-bar/build/loading_bar_middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = loadingBarMiddleware;
    var _loading_bar_ducks = require_loading_bar_ducks();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var defaultTypeSuffixes = ["PENDING", "FULFILLED", "REJECTED"];
    function loadingBarMiddleware() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypeSuffixes;
      var scope = config.scope || _loading_bar_ducks.DEFAULT_SCOPE;
      return function(_ref) {
        var dispatch = _ref.dispatch;
        return function(next) {
          return function(action) {
            if (action.type) {
              var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3), PENDING = _promiseTypeSuffixes[0], FULFILLED = _promiseTypeSuffixes[1], REJECTED = _promiseTypeSuffixes[2];
              var isPending = new RegExp("".concat(PENDING, "$"), "g");
              var isFulfilled = new RegExp("".concat(FULFILLED, "$"), "g");
              var isRejected = new RegExp("".concat(REJECTED, "$"), "g");
              var actionScope = action.meta && action.meta.scope || action.scope || scope;
              if (action.type.match(isPending)) {
                dispatch((0, _loading_bar_ducks.showLoading)(actionScope));
              } else if (action.type.match(isFulfilled) || action.type.match(isRejected)) {
                dispatch((0, _loading_bar_ducks.hideLoading)(actionScope));
              }
            }
            return next(action);
          };
        };
      };
    }
  }
});

// node_modules/react-redux-loading-bar/build/immutable.js
var require_immutable = __commonJS({
  "node_modules/react-redux-loading-bar/build/immutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _reactRedux = require_cjs();
    var _loading_bar = require_loading_bar();
    var _loading_bar_ducks = require_loading_bar_ducks();
    var mapImmutableStateToProps = function mapImmutableStateToProps2(state, ownProps) {
      return {
        loading: state.get("loadingBar")[ownProps.scope || _loading_bar_ducks.DEFAULT_SCOPE]
      };
    };
    var _default = (0, _reactRedux.connect)(mapImmutableStateToProps)(_loading_bar.LoadingBar);
    exports["default"] = _default;
  }
});

// node_modules/react-redux-loading-bar/build/index.js
var require_build = __commonJS({
  "node_modules/react-redux-loading-bar/build/index.js"(exports) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LoadingBar", {
      enumerable: true,
      get: function get() {
        return _loading_bar.LoadingBar;
      }
    });
    Object.defineProperty(exports, "loadingBarMiddleware", {
      enumerable: true,
      get: function get() {
        return _loading_bar_middleware["default"];
      }
    });
    Object.defineProperty(exports, "DEFAULT_SCOPE", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.DEFAULT_SCOPE;
      }
    });
    Object.defineProperty(exports, "HIDE", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.HIDE;
      }
    });
    Object.defineProperty(exports, "hideLoading", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.hideLoading;
      }
    });
    Object.defineProperty(exports, "loadingBarReducer", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.loadingBarReducer;
      }
    });
    Object.defineProperty(exports, "RESET", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.RESET;
      }
    });
    Object.defineProperty(exports, "resetLoading", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.resetLoading;
      }
    });
    Object.defineProperty(exports, "SHOW", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.SHOW;
      }
    });
    Object.defineProperty(exports, "showLoading", {
      enumerable: true,
      get: function get() {
        return _loading_bar_ducks.showLoading;
      }
    });
    Object.defineProperty(exports, "ImmutableLoadingBar", {
      enumerable: true,
      get: function get() {
        return _immutable["default"];
      }
    });
    exports["default"] = void 0;
    var _loading_bar = _interopRequireWildcard(require_loading_bar());
    var _loading_bar_middleware = _interopRequireDefault(require_loading_bar_middleware());
    var _loading_bar_ducks = require_loading_bar_ducks();
    var _immutable = _interopRequireDefault(require_immutable());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _default = _loading_bar["default"];
    exports["default"] = _default;
  }
});
export default require_build();
//# sourceMappingURL=react-redux-loading-bar.js.map
